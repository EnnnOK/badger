# txn



## oracle
检查冲突

## get
先从 db memtables 获取，如果key，版本相同，直接返回。
如果版本不同，返回版本最大的，去 levelController 中寻找。
db.go#L747 为什么版本不同的时候，不直接返回值，而要去 levelController 中寻找？可能 value 数据被清理了,为了节省空间

mvcc 控制，由 oracle 对象保留了所有的提交过的事务，在新的事务提交的时候，由 oracle 的已经提交过的事务检查是否有冲突。

entry 的 version 是时间戳。

entry 检查无误后，发送给 channel 进行提交。

提交之前，先写 value log

db memtable 和 levelController 的 table 不是一个对象

todo: memtable 怎么持久化。

ACID 以及 mvcc 的实现
[https://dgraph.io/blog/post/badger-txn/](https://dgraph.io/blog/post/badger-txn/)

Badger 允许事务的并行执行（boltdb 不能）。当新开启一个事务的时候，会从内存的 oracle 变量中拿出一个时间戳。这个 oracle 变量是被 db 对象持有的，全局只有一个。所有的读事务都依赖这个时间戳。读取数据的时候，会存储一个key 的指纹。（用指纹替代 key 的原因是为了节省空间） 在只读事务中，避免了追踪每个读的请求，这样避免了从快照读的时候内存爆炸。

当写事务开始的时候，将事务中的所有的写操作放在事务对象中的缓存当中。接下来这个事务读取的时候会从内存当中读取到这个值。但是其他事务不会读取到，这样就实现了隔离(I)和一致性(C)。

最后，当事务提交的时候，将事务的读指纹提交给 oracle 对象，然后 oracle 对象会返回一个提交的时间戳。oracle 会检查被读取的变量是否发生了修改，如果发生了修改，那么久会产生冲突，这个事务就会被丢弃。

如果没有检测到冲突，oracle 对象会产生出一个新的独一无二的提交时间戳，然后将事务修改的数据更新到内存当中用于检测之后的冲突。这里是先更新到内存中在写磁盘，因此即使写入磁盘的时候发生了错误，也不会产生任何逻辑上的问题。


在这一点上，每个 key 都带有了一个提交的时间戳用于实现 MVCC。

一旦提交了时间戳，所有写事务的修改会被发送到一个 channel 中，然后排队被写入到 valuelog 中。一旦 valuelog 写入成功，这样就实现了数据的持久性（D)了，如果后面程序崩溃了，可以通过 valuelog 复现然后恢复。

当写入到 valuelog 完成之后，lsm tree 里面的数据就会被更新，因此之后的事务就可以看到这些被修改IDE时间了。如果写到 valuelog 失败了，数据是不会修改到 lsm tree 中，这个事务就被丢弃掉了。因为档写入磁盘之后， lsm tree 不会被更新，所以之后的事务也不会看到修改的数据，这样就实现了原子性（A)。

oracle 对象会一直保持跟中即将提交的事务在一个最小堆中。一旦事务提交成功，oracle 会马上更新起读时间戳，因此新的事务就会从新的版本开始。




